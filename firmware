/* ADC Firmware for STM32F030 - 8-Channel Raspberry Pi Hat */
#include "stm32f0xx_hal.h"

// Configuration
#define DEFAULT_I2C_ADDR         0x04    // Default address
#define COMMAND_CHANGE_ADDR      0x55    // Command byte
#define FLASH_ADDR_STORAGE       0x0800FC00  // Flash storage location
#define NUM_CHANNELS             8       // 8 ADC channels

// Register map (must match Python code)
#define REG_RAW_DATA_START      0x10    // Raw ADC values (0x10-0x17)
#define REG_VOL_START           0x20    // Voltage values (0x20-0x27)
#define REG_RTO_START           0x30    // Ratio values (0x30-0x37)
#define REG_SET_ADDR            0xC0    // Address change register

typedef struct {
    uint16_t raw_data[NUM_CHANNELS];    // 0x10-0x17
    uint16_t voltage[NUM_CHANNELS];     // 0x20-0x27
    uint16_t ratio[NUM_CHANNELS];       // 0x30-0x37
    uint8_t config;                     // 0xC0
} ADC_Registers;

typedef struct {
    ADC_Registers* regs;
    uint8_t i2c_addr;
    uint8_t active_channel;
    uint16_t adc_values[NUM_CHANNELS];
    uint16_t calibration;
} ADC_State;

ADC_State adc_state;
I2C_HandleTypeDef hi2c1;

// Flash write helper
void Write_To_Flash(uint32_t address, uint8_t data) {
    HAL_FLASH_Unlock();
    FLASH_EraseInitTypeDef erase = {
        .TypeErase = FLASH_TYPEERASE_PAGES,
        .PageAddress = address,
        .NbPages = 1
    };
    uint32_t err;
    HAL_FLASHEx_Erase(&erase, &err);
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, address, data);
    HAL_FLASH_Lock();
}

// Change I2C address
HAL_StatusTypeDef Change_I2C_Address(uint8_t new_addr) {
    if(new_addr < 0x08 || new_addr > 0x77) return HAL_ERROR;

    adc_state.i2c_addr = new_addr;
    Write_To_Flash(FLASH_ADDR_STORAGE, new_addr);

    // Reinit I2C with new address
    hi2c1.Instance->OAR1 = (new_addr << 1);
    return HAL_OK;
}

// I2C Slave Callback
void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c) {
    uint8_t rx_data[2];
    HAL_I2C_Slave_Receive(&hi2c1, rx_data, 2, HAL_MAX_DELAY);

    if(rx_data[0] == REG_SET_ADDR) {
        Change_I2C_Address(rx_data[1]);
    }
}

// Update ADC measurements
void Update_ADC_Values() {
    for(uint8_t ch = 0; ch < NUM_CHANNELS; ch++) {
        // Read actual ADC here - simplified for example
        adc_state.adc_values[ch] = HAL_ADC_GetValue(&hadc);

        // Update registers
        adc_state.regs->raw_data[ch] = adc_state.adc_values[ch];
        adc_state.regs->voltage[ch] = (adc_state.adc_values[ch] * 3300) / 4095;
        adc_state.regs->ratio[ch] = (adc_state.adc_values[ch] * 1000) / 4095;
    }
}

// Main Initialization
void ADC_Init() {
    // Initialize registers
    adc_state.regs = (ADC_Registers*)0x40000000; // Example base address

    // Check for stored address
    uint8_t stored_addr = *(uint8_t*)FLASH_ADDR_STORAGE;
    adc_state.i2c_addr = (stored_addr != 0xFF) ? stored_addr : DEFAULT_I2C_ADDR;

    // I2C Configuration
    hi2c1.Instance = I2C1;
    hi2c1.Init.Timing = 0x2000090E;
    hi2c1.Init.OwnAddress1 = (adc_state.i2c_addr << 1);
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    HAL_I2C_Init(&hi2c1);

    // Enable I2C interrupts
    HAL_I2C_EnableListen_IT(&hi2c1);
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    ADC_Init();

    while (1) {
        Update_ADC_Values();
        HAL_Delay(10);
    }
}